{"version":3,"sources":["webpack:///./node_modules/svg-path-parser/index.js","webpack:///./node_modules/svg-path-parser/parser.js"],"names":["parserFunction","__webpack_require__","parse","parseSVG","makeAbsolute","commands","subpathStart","prevCmd","x","y","attr","x1","y1","x2","y2","forEach","cmd","a","command","x0","y0","relative","code","toUpperCase","module","exports","peg$SyntaxError","message","expected","found","location","this","name","Error","captureStackTrace","child","parent","ctor","constructor","prototype","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","i","escapedParts","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","s","replace","j","descriptions","type","sort","slice","join","SyntaxError","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","svg_path","peg$parsesvg_path","peg$startRuleFunction","peg$c0","data","cmds","concat","apply","first","peg$c1","more","l","peg$c2","peg$c3","peg$classExpectation","peg$c4","c","move","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","args","peg$c11","peg$c12","peg$c13","map","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","b","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","rx","ry","xrot","large","sweep","xy","xAxisRotation","largeArc","peg$c31","peg$c32","n","peg$c33","peg$c34","peg$c35","peg$c36","bit","peg$c37","peg$c38","peg$c39","peg$literalExpectation","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","digits","peg$c50","peg$c51","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","start","offset","peg$fail","push","s0","s1","s2","s3","s4","peg$parsewsp","s5","peg$parsemoveTo_drawTo_commandGroup","s6","test","charAt","peg$parsecoordinate_pair","peg$parsecomma_wsp","peg$parselineto_argument_sequence","peg$parsedrawto_command","peg$parsecoordinate_sequence","peg$parsecurveto_argument","peg$parsesmooth_curveto_argument","peg$parsequadratic_bezier_curveto_argument","peg$parseelliptical_arc_argument","peg$parsenumber","s7","s8","s9","s10","s11","peg$parsenonnegative_number","peg$parseflag","peg$parsefloating_point_constant","peg$parsedigit_sequence","peg$parsesign","peg$parsecomma","peg$parseexponent","m","h","v","q","t","z","k","toLowerCase","peg$buildStructuredError"],"mappings":"6EAEA,IAAAA,EAAAC,EAAA,KAAAC,MACAF,EAAAG,SAAAH,EACAA,EAAAI,aAGA,SAAAC,GACA,IAAAC,EAAAC,GAA4BC,EAAA,EAAAC,EAAA,GAC5BC,GAAaF,EAAA,KAAAC,EAAA,KAAAE,GAAA,KAAAC,GAAA,KAAAC,GAAA,KAAAC,GAAA,MAeb,OAdAT,EAAAU,QAAA,SAAAC,GAGA,QAAAC,IAFA,WAAAD,EAAAE,UAAAZ,EAAAU,GACAA,EAAAG,GAAAZ,EAAAC,EAAmBQ,EAAAI,GAAAb,EAAAE,EACnBC,EAAAO,KAAAD,MAAAC,IAAAD,EAAAK,SAAAL,EAAAN,EAAAO,IAAA,GACA,MAAAD,MAAAR,EAAAD,EAAAC,GACA,MAAAQ,MAAAP,EAAAF,EAAAE,GACAO,EAAAK,YACAL,EAAAM,KAAAN,EAAAM,KAAAC,cACA,aAAAP,EAAAE,UACAF,EAAAR,EAAAF,EAAAE,EACAQ,EAAAP,EAAAH,EAAAG,GAEAF,EAAAS,IAEAX,GAnBAmB,EAAAC,QAAAzB,oCCSA,SAAA0B,EAAAC,EAAAC,EAAAC,EAAAC,GACAC,KAAAJ,UACAI,KAAAH,WACAG,KAAAF,QACAE,KAAAD,WACAC,KAAAC,KAAA,cAEA,mBAAAC,MAAAC,mBACAD,MAAAC,kBAAAH,KAAAL,IAdA,SAAAS,EAAAC,GACA,SAAAC,IAAmBN,KAAAO,YAAAH,EACnBE,EAAAE,UAAAH,EAAAG,UACAJ,EAAAI,UAAA,IAAAF,EAHA,CAkBAX,EAAAO,OAEAP,EAAAc,aAAA,SAAAZ,EAAAC,GACA,IAAAY,GACAC,QAAA,SAAAC,GACA,UAAAC,EAAAD,EAAAE,MAAA,KAGAC,MAAA,SAAAH,GACA,IACAI,EADAC,EAAA,GAGA,IAAAD,EAAA,EAAqBA,EAAAJ,EAAAM,MAAAC,OAA8BH,IACnDC,GAAAL,EAAAM,MAAAF,aAAAI,MACAC,EAAAT,EAAAM,MAAAF,GAAA,QAAAK,EAAAT,EAAAM,MAAAF,GAAA,IACAK,EAAAT,EAAAM,MAAAF,IAGA,WAAAJ,EAAAU,SAAA,QAAAL,EAAA,KAGAM,IAAA,SAAAX,GACA,uBAGAY,IAAA,SAAAZ,GACA,sBAGAa,MAAA,SAAAb,GACA,OAAAA,EAAAc,cAIA,SAAAC,EAAAC,GACA,OAAAA,EAAAC,WAAA,GAAAC,SAAA,IAAAtC,cAGA,SAAAqB,EAAAkB,GACA,OAAAA,EACAC,QAAA,cACAA,QAAA,YACAA,QAAA,aACAA,QAAA,aACAA,QAAA,aACAA,QAAA,aACAA,QAAA,wBAAAJ,GAAsD,aAAAD,EAAAC,KACtDI,QAAA,iCAAAJ,GAAsD,YAAAD,EAAAC,KAGtD,SAAAP,EAAAU,GACA,OAAAA,EACAC,QAAA,cACAA,QAAA,aACAA,QAAA,aACAA,QAAA,YACAA,QAAA,aACAA,QAAA,aACAA,QAAA,aACAA,QAAA,aACAA,QAAA,wBAAAJ,GAAsD,aAAAD,EAAAC,KACtDI,QAAA,iCAAAJ,GAAsD,YAAAD,EAAAC,KA6CtD,kBAtCA,SAAA/B,GACA,IACAmB,EAAAiB,EANArB,EAKAsB,EAAA,IAAAd,MAAAvB,EAAAsB,QAGA,IAAAH,EAAA,EAAeA,EAAAnB,EAAAsB,OAAqBH,IACpCkB,EAAAlB,IATAJ,EASAf,EAAAmB,GARAN,EAAAE,EAAAuB,MAAAvB,IAaA,GAFAsB,EAAAE,OAEAF,EAAAf,OAAA,GACA,IAAAH,EAAA,EAAAiB,EAAA,EAAwBjB,EAAAkB,EAAAf,OAAyBH,IACjDkB,EAAAlB,EAAA,KAAAkB,EAAAlB,KACAkB,EAAAD,GAAAC,EAAAlB,GACAiB,KAGAC,EAAAf,OAAAc,EAGA,OAAAC,EAAAf,QACA,OACA,OAAAe,EAAA,GAEA,OACA,OAAAA,EAAA,UAAAA,EAAA,GAEA,QACA,OAAAA,EAAAG,MAAA,MAAAC,KAAA,MACA,QACAJ,IAAAf,OAAA,IA9BA,CAsCAtB,GAAA,SAAAC,EAHA,IAAAe,EAGAf,GAHA,oBAGA,WA44DAL,EAAAC,SACA6C,YAAA5C,EACAxB,MA34DA,SAAAqE,EAAAC,GACAA,kBAEA,IA8EAC,EA9EAC,KAEAC,GAAgCC,SAAAC,IAChCC,EAAAD,GAEAE,EAAA,SAAAC,GACA,IAAAA,EAAA,SACA,QAAAC,KAAAlC,EAAA,EAA+BA,EAAAiC,EAAA9B,OAAcH,IAAAkC,IAAAC,OAAAC,MAAAF,EAAAD,EAAAjC,IAC7C,IAAAqC,EAAAH,EAAA,GAKA,OAJAG,GAAA,KAAAA,EAAA9D,cACA8D,EAAA/D,SACA+D,EAAA9D,KAAA,KAEA2D,GAEAI,EAAA,SAAAD,EAAAE,GAAsC,OAg1DtC,SAAAF,EAAAE,GACA,IAAAA,EAAA,OAAAF,GACA,QAAAnE,GAAAmE,GAAArC,EAAA,EAAAwC,EAAAD,EAAApC,OAA2CH,EAAAwC,EAAIxC,IAAA9B,EAAA8B,EAAA,GAAAuC,EAAAvC,GAAA,GAC/C,OAAA9B,EAHA,CAh1DsCmE,EAAAE,IACtCE,EAAA,QACAC,EAAAC,IAAA,gBACAC,EAAA,SAAAC,EAAAR,EAAAE,GACA,IAAAO,EAAAxF,GAAAuF,GAAAR,IAEA,OADAE,IAAAO,IAAAX,OAAA7E,GAAA,KAAAuF,EAAA,QAAAN,EAAA,MACAO,GAEAC,EAAA,QACAC,EAAAL,IAAA,gBACAM,EAAA,WAA2B,OAAA3F,GAAA,MAC3B4F,EAAA,QACAC,EAAAR,IAAA,gBACAS,EAAA,SAAAP,EAAAQ,GAAmC,OAAA/F,GAAAuF,EAAAQ,IACnCC,EAAA,QACAC,EAAAZ,IAAA,gBACAa,EAAA,SAAAX,EAAAQ,GAAmC,OAAA/F,GAAAuF,EAAAQ,EAAAI,IAAA,SAAAhG,GAAwC,OAASA,SACpFiG,EAAA,QACAC,EAAAhB,IAAA,gBACAiB,EAAA,SAAAf,EAAAQ,GAAmC,OAAA/F,GAAAuF,EAAAQ,EAAAI,IAAA,SAAA/F,GAAwC,OAASA,SACpFmG,EAAA,QACAC,EAAAnB,IAAA,gBACAoB,EAAA,SAAA7F,EAAA8F,EAAAnB,GAAmC,OAASjF,GAAAM,EAAAT,EAAAI,GAAAK,EAAAR,EAAAI,GAAAkG,EAAAvG,EAAAM,GAAAiG,EAAAtG,EAAAD,EAAAoF,EAAApF,EAAAC,EAAAmF,EAAAnF,IAC5CuG,EAAA,QACAC,EAAAvB,IAAA,gBACAwB,EAAA,SAAAH,EAAAnB,GAAgC,OAAS/E,GAAAkG,EAAAvG,EAAAM,GAAAiG,EAAAtG,EAAAD,EAAAoF,EAAApF,EAAAC,EAAAmF,EAAAnF,IACzC0G,EAAA,QACAC,EAAA1B,IAAA,gBACA2B,EAAA,SAAApG,EAAA8F,GAAgC,OAASpG,GAAAM,EAAAT,EAAAI,GAAAK,EAAAR,EAAAD,EAAAuG,EAAAvG,EAAAC,EAAAsG,EAAAtG,IACzC6G,EAAA,QACAC,EAAA7B,IAAA,gBACA8B,EAAA,QACAC,EAAA/B,IAAA,gBACAgC,EAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAA0D,OAASL,KAAAC,KAAAK,cAAAJ,EAAAK,SAAAJ,EAAAC,QAAAvH,EAAAwH,EAAAxH,EAAAC,EAAAuH,EAAAvH,IACnE0H,EAAA,SAAA3H,EAAAC,GAAgC,OAASD,IAAAC,MACzC2H,EAAA,SAAAC,GAA6B,SAAAA,GAC7BC,EAAA,SAAArF,GAAiC,SAAAA,EAAAoB,KAAA,KACjCkE,EAAA,QACAC,EAAA9C,IAAA,gBACA+C,EAAA,SAAAC,GAA+B,WAAAA,GAC/BC,EAAA,WAA4B,UAC5BC,EAAA,IACAC,EAAAC,GAAA,QACAC,EAAA,SAAA9F,GAAiC,OAAAA,EAAAoB,KAAA,KACjC2E,EAAA,IACAC,EAAAH,GAAA,QACAI,EAAA,QACAC,EAAAzD,IAAA,gBACA0D,EAAA,SACAC,EAAA3D,IAAA,gBACA4D,GAAA,SACAC,GAAA7D,KAAA,iBACA8D,GAAA,SAAAC,GAAkC,OAAAA,EAAApF,KAAA,KAClCqF,GAAA,aACAC,GAAAjE,IAAA,2BAEAkE,GAAA,EAEAC,KAA+BC,KAAA,EAAAC,OAAA,IAC/BC,GAAA,EACAC,MACAC,GAAA,EAIA,iBAAA1F,EAAA,CACA,KAAAA,EAAA2F,aAAAxF,GACA,UAAA1C,MAAA,mCAAAuC,EAAA2F,UAAA,MAGArF,EAAAH,EAAAH,EAAA2F,WA2BA,SAAArB,GAAAjG,EAAAuH,GACA,OAAYlG,KAAA,UAAArB,OAAAuH,cAGZ,SAAA1E,GAAAzC,EAAAI,EAAA+G,GACA,OAAYlG,KAAA,QAAAjB,QAAAI,WAAA+G,cAeZ,SAAAC,GAAAC,GACA,IAAAC,EAAAC,EAAAX,GAAAS,GAEA,GAAAE,EACA,OAAAA,EAGA,IADAD,EAAAD,EAAA,GACAT,GAAAU,IACAA,IASA,IALAC,GACAV,MAFAU,EAAAX,GAAAU,IAEAT,KACAC,OAAAS,EAAAT,QAGAQ,EAAAD,GACA,KAAA/F,EAAAX,WAAA2G,IACAC,EAAAV,OACAU,EAAAT,OAAA,GAEAS,EAAAT,SAGAQ,IAIA,OADAV,GAAAS,GAAAE,EACAA,EAIA,SAAAC,GAAAC,EAAAC,GACA,IAAAC,EAAAP,GAAAK,GACAG,EAAAR,GAAAM,GAEA,OACAG,OACAC,OAAAL,EACAZ,KAAAc,EAAAd,KACAC,OAAAa,EAAAb,QAEAxG,KACAwH,OAAAJ,EACAb,KAAAe,EAAAf,KACAC,OAAAc,EAAAd,SAKA,SAAAiB,GAAApJ,GACAgI,GAAAI,KAEAJ,GAAAI,KACAA,GAAAJ,GACAK,OAGAA,GAAAgB,KAAArJ,IAgBA,SAAAiD,KACA,IAAAqG,EAAAC,EAAAC,EAAAC,EAAAC,EAKA,IAHAJ,EAAAtB,GACAuB,KACAC,EAAAG,KACAH,IAAA1G,GACAyG,EAAAF,KAAAG,GACAA,EAAAG,KAEA,GAAAJ,IAAAzG,EAKA,IAJA0G,EA+BA,WACA,IAAAF,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAM,QACA/G,EAAA,CAKA,IAJA0G,KACAC,EAAAzB,GACA0B,KACAE,EAAAD,KACAC,IAAA9G,GACA4G,EAAAL,KAAAO,GACAA,EAAAD,KAeA,IAbAD,IAAA5G,IACA8G,EAAAC,QACA/G,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GAAA,CAKA,IAJA0G,EAAAH,KAAAI,GACAA,EAAAzB,GACA0B,KACAE,EAAAD,KACAC,IAAA9G,GACA4G,EAAAL,KAAAO,GACAA,EAAAD,KAEAD,IAAA5G,IACA8G,EAAAC,QACA/G,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA/DA,MA9BAxG,IACA0G,EAAA,MAEAA,IAAA1G,EAAA,CAGA,IAFA2G,KACAC,EAAAC,KACAD,IAAA5G,GACA2G,EAAAJ,KAAAK,GACAA,EAAAC,KAEAF,IAAA3G,EAGAwG,EADAC,EAAApG,EAAAqG,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,OAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EAqEA,SAAAO,KACA,IAAAP,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EA8FA,WACA,IAAAD,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAAAE,EAUA,GARAR,EAAAtB,GACApE,EAAAmG,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAAvF,IAElC0F,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAAAQ,QACAnH,GACA4G,EAAA1B,IACA4B,EAAAM,QACApH,IACA8G,EAAA,MAEAA,IAAA9G,IACAgH,EAAAK,QACArH,EAEA4G,EADAE,KAAAE,IAOA9B,GAAA0B,EACAA,EAAA5G,GAEA4G,IAAA5G,IACA4G,EAAA,MAEAA,IAAA5G,EAGAwG,EADAC,EAAAxF,EAAAwF,EAAAE,EAAAC,IAGA1B,GAAAsB,EACAA,EAAAxG,KAOAkF,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA/DA,MA7FAxG,EAAA,CAKA,IAJA0G,KACAC,EAAAzB,GACA0B,KACAE,EAAAD,KACAC,IAAA9G,GACA4G,EAAAL,KAAAO,GACAA,EAAAD,KAeA,IAbAD,IAAA5G,IACA8G,EAAAQ,QACAtH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GAAA,CAKA,IAJA0G,EAAAH,KAAAI,GACAA,EAAAzB,GACA0B,KACAE,EAAAD,KACAC,IAAA9G,GACA4G,EAAAL,KAAAO,GACAA,EAAAD,KAEAD,IAAA5G,IACA8G,EAAAQ,QACAtH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EAGA,SAAAc,KACA,IAAAd,EAkGAC,EAtEA,OAyEArF,EAAA6F,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAAjF,IAElCoF,IAAAzG,IAEAyG,EAAAnF,MA5GAkF,EA8GAC,KA7GAzG,IACAwG,EAiHA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACA3D,EAAA0F,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAA9E,IAElCiF,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAAAU,QACArH,EAGAwG,EADAC,EAAAhF,EAAAgF,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,MAhHAxG,IACAwG,EAqNA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACAvD,EAAAsF,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAA1E,IAElC6E,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAAAY,QACAvH,EAGAwG,EADAC,EAAA5E,EAAA4E,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,MApNAxG,IACAwG,EAyTA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACAnD,EAAAkF,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAAtE,IAElCyE,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAAAY,QACAvH,EAGAwG,EADAC,EAAAxE,EAAAwE,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,MAxTAxG,IACAwG,EA+VA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACAhD,EAAA+E,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAAnE,IAElCsE,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAqBA,WACA,IAAAH,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAe,QACAxH,EAAA,CAoBA,IAnBA0G,KACAC,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAU,QACAxH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAU,QACAxH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA3DA,MApBAxG,EAGAwG,EADAC,EAAAhF,EAAAgF,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,MA9VAxG,IACAwG,EAkfA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACA5C,EAAA2E,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAA/D,IAElCkE,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAqBA,WACA,IAAAH,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAgB,QACAzH,EAAA,CAoBA,IAnBA0G,KACAC,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAW,QACAzH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAW,QACAzH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA3DA,MApBAxG,EAGAwG,EADAC,EAAAhF,EAAAgF,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,MAjfAxG,IACAwG,EAsnBA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACAzC,EAAAwE,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAA5D,IAElC+D,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAqBA,WACA,IAAAH,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAiB,QACA1H,EAAA,CAoBA,IAnBA0G,KACAC,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAY,QACA1H,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAY,QACA1H,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA3DA,MApBAxG,EAGAwG,EADAC,EAAAhF,EAAAgF,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,MArnBAxG,IACAwG,EA0vBA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACAtC,EAAAqE,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAAzD,IAElC4D,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAqBA,WACA,IAAAH,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAU,QACAnH,EAAA,CAoBA,IAnBA0G,KACAC,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAK,QACAnH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAK,QACAnH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA3DA,MApBAxG,EAGAwG,EADAC,EAAAhF,EAAAgF,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,MAzvBAxG,IACAwG,EA81BA,WACA,IAAAA,EAAAC,EAAAC,EAAAC,EAUA,GARAH,EAAAtB,GACApC,EAAAmE,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAAvD,IAElC0D,IAAAzG,EAAA,CAGA,IAFA0G,KACAC,EAAAE,KACAF,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAE,KAEAH,IAAA1G,IACA2G,EAqBA,WACA,IAAAH,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAkB,QACA3H,EAAA,CAoBA,IAnBA0G,KACAC,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAa,QACA3H,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAa,QACA3H,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA3DA,MApBAxG,EAGAwG,EADAC,EAAAhF,EAAAgF,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EArCA,IAp1BAA,EAiIA,SAAAa,KACA,IAAAb,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAU,QACAnH,EAAA,CAoBA,IAnBA0G,KACAC,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAK,QACAnH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAK,QACAnH,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EA2CA,SAAAe,KACA,IAAAf,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAIA,GAFAN,EAAAtB,IACAuB,EAAAmB,QACA5H,EAAA,CAoBA,IAnBA0G,KACAC,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAc,QACA5H,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAEA2G,IAAA3G,GACA0G,EAAAH,KAAAI,GACAA,EAAAzB,IACA0B,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAc,QACA5H,EAEA2G,EADAC,KAAAE,IAOA5B,GAAAyB,EACAA,EAAA3G,GAGA0G,IAAA1G,EAGAwG,EADAC,EAAA9F,EAAA8F,EAAAC,IAGAxB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,EAGA,OAAAwG,EAiJA,SAAAgB,KACA,IAAAhB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EA2CA,OAzCAN,EAAAtB,IACAuB,EAAAU,QACAnH,IACA0G,EAAAU,QACApH,IACA0G,EAAA,MAEAA,IAAA1G,IACA2G,EAAAQ,QACAnH,IACA4G,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAK,QACAnH,EAGAwG,EADAC,EAAArE,EAAAqE,EAAAE,EAAAG,IAOA5B,GAAAsB,EACAA,EAAAxG,KAOAkF,GAAAsB,EACAA,EAAAxG,KAGAkF,GAAAsB,EACAA,EAAAxG,GAGAwG,EAyGA,SAAAiB,KACA,IAAAjB,EAAAC,EAAAC,EAAAC,EA4BA,OA1BAH,EAAAtB,IACAuB,EAAAU,QACAnH,IACA0G,EAAAU,QACApH,IACA0G,EAAA,MAEAA,IAAA1G,IACA2G,EAAAQ,QACAnH,EAGAwG,EADAC,EAAAjE,EAAAiE,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,KAGAkF,GAAAsB,EACAA,EAAAxG,GAGAwG,EAyGA,SAAAkB,KACA,IAAAlB,EAAAC,EAAAC,EAAAC,EA4BA,OA1BAH,EAAAtB,IACAuB,EAAAU,QACAnH,IACA0G,EAAAU,QACApH,IACA0G,EAAA,MAEAA,IAAA1G,IACA2G,EAAAQ,QACAnH,EAGAwG,EADAC,EAAA9D,EAAA8D,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,KAGAkF,GAAAsB,EACAA,EAAAxG,GAGAwG,EA+MA,SAAAmB,KACA,IAAAnB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAAAe,EAAAC,EAAAC,EAAAC,EAAAC,EAqFA,OAnFAzB,EAAAtB,IACAuB,EAAAyB,QACAlI,IACA0G,EAAAU,QACApH,IACA0G,EAAA,MAEAA,IAAA1G,IACA2G,EAAAuB,QACAlI,IACA4G,EAAAQ,QACApH,IACA4G,EAAA,MAEAA,IAAA5G,IACA8G,EAAAc,QACA5H,GACAoH,OACApH,IACA6H,EAAAM,QACAnI,IACA8H,EAAAV,QACApH,IACA8H,EAAA,MAEAA,IAAA9H,IACA+H,EAAAI,QACAnI,IACAgI,EAAAZ,QACApH,IACAgI,EAAA,MAEAA,IAAAhI,IACAiI,EAAAd,QACAnH,EAGAwG,EADAC,EAAAzD,EAAAyD,EAAAE,EAAAG,EAAAe,EAAAE,EAAAE,IAOA/C,GAAAsB,EACAA,EAAAxG,KAOAkF,GAAAsB,EACAA,EAAAxG,KAeAkF,GAAAsB,EACAA,EAAAxG,KAOAkF,GAAAsB,EACAA,EAAAxG,KAGAkF,GAAAsB,EACAA,EAAAxG,GAGAwG,EAGA,SAAAW,KACA,IAAAX,EAAAC,EAAAC,EAAAC,EA4BA,OA1BAH,EAAAtB,IACAuB,EAAAmB,QACA5H,IACA0G,EAAAU,QACApH,IACA0G,EAAA,MAEAA,IAAA1G,IACA2G,EAAAiB,QACA5H,EAGAwG,EADAC,EAAAhD,EAAAgD,EAAAE,IAOAzB,GAAAsB,EACAA,EAAAxG,KAGAkF,GAAAsB,EACAA,EAAAxG,GAGAwG,EAGA,SAAA0B,KACA,IAAAzB,EAaA,OAVAA,EAAA2B,QACApI,IACAyG,EAAA4B,MAEA5B,IAAAzG,IAEAyG,EAAA/C,EAAA+C,IAEAA,EAKA,SAAAmB,KACA,IAAAnB,EAAAC,EAAAC,EA+CA,OA5CAF,EAAAvB,IACAwB,EAAA4B,QACAtI,IACA0G,EAAA,MAEAA,IAAA1G,IACA2G,EAAAyB,QACApI,EAEAyG,EADAC,KAAAC,IAOAzB,GAAAuB,EACAA,EAAAzG,GAEAyG,IAAAzG,IACAyG,EAAAvB,IACAwB,EAAA4B,QACAtI,IACA0G,EAAA,MAEAA,IAAA1G,IACA2G,EAAA0B,QACArI,EAEAyG,EADAC,KAAAC,IAOAzB,GAAAuB,EACAA,EAAAzG,IAGAyG,IAAAzG,IAEAyG,EAAA7C,EAAA6C,IAEAA,EAKA,SAAA0B,KACA,IAAA1B,EAgBA,OAbA5C,EAAAoD,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAAxC,IAElC2C,IAAAzG,IAEAyG,EAAA1C,EAAA0C,IAEAA,EAKA,SAAAW,KACA,IAAAZ,EAAAC,EAAAC,EAAAC,EAAAC,EAKA,GAHAJ,EAAAtB,GACAuB,MACAC,EAAAG,QACA7G,EACA,KAAA0G,IAAA1G,GACAyG,EAAAF,KAAAG,GACAA,EAAAG,UAGAJ,EAAAzG,EAEA,GAAAyG,IAAAzG,EAKA,IAJA0G,EAAA6B,QACAvI,IACA0G,EAAA,MAEAA,IAAA1G,EAAA,CAGA,IAFA2G,KACAC,EAAAC,KACAD,IAAA5G,GACA2G,EAAAJ,KAAAK,GACAA,EAAAC,KAEAF,IAAA3G,EAEAwG,EADAC,KAAAC,EAAAC,IAGAzB,GAAAsB,EACAA,EAAAxG,QAGAkF,GAAAsB,EACAA,EAAAxG,OAGAkF,GAAAsB,EACAA,EAAAxG,EAEA,GAAAwG,IAAAxG,EAAA,CAIA,GAHAwG,EAAAtB,GACAuB,EAAAvB,IACAwB,EAAA6B,QACAvI,EAAA,CAGA,IAFA2G,KACAC,EAAAC,KACAD,IAAA5G,GACA2G,EAAAJ,KAAAK,GACAA,EAAAC,KAEAF,IAAA3G,EAEAyG,EADAC,KAAAC,IAGAzB,GAAAuB,EACAA,EAAAzG,QAGAkF,GAAAuB,EACAA,EAAAzG,EAEAyG,IAAAzG,IAEAyG,EAAAxC,KAEAuC,EAAAC,EAGA,OAAAD,EAGA,SAAA+B,KACA,IAAA/B,EAUA,OARA,KAAA3G,EAAAX,WAAAgG,KACAsB,EAAAtC,EACAgB,OAEAsB,EAAAxG,EACA,IAAAwF,IAAkCc,GAAAnC,IAGlCqC,EAGA,SAAA4B,KACA,IAAA3B,EAAAC,EAAAC,EA4CA,OAzCAF,EAAAvB,IACAwB,EA2CA,WACA,IAAAD,EAAAC,EAAAC,EAAAC,EA8DA,OA3DAH,EAAAvB,IACAwB,EAAA2B,QACArI,IACA0G,EAAA,MAEAA,IAAA1G,GACA,KAAAH,EAAAX,WAAAgG,KACAyB,EAAArC,EACAY,OAEAyB,EAAA3G,EACA,IAAAwF,IAAoCc,GAAA/B,IAEpCoC,IAAA3G,IACA4G,EAAAyB,QACArI,EAEAyG,EADAC,KAAAC,EAAAC,IAOA1B,GAAAuB,EACAA,EAAAzG,KAGAkF,GAAAuB,EACAA,EAAAzG,GAEAyG,IAAAzG,IACAyG,EAAAvB,IACAwB,EAAA2B,QACArI,GACA,KAAAH,EAAAX,WAAAgG,KACAyB,EAAArC,EACAY,OAEAyB,EAAA3G,EACA,IAAAwF,IAAsCc,GAAA/B,IAEtCoC,IAAA3G,EAEAyG,EADAC,KAAAC,IAGAzB,GAAAuB,EACAA,EAAAzG,KAGAkF,GAAAuB,EACAA,EAAAzG,IAGAyG,IAAAzG,IAEAyG,EAAApC,EAAAoC,IAEAA,EA7DA,MA1CAzG,IACA2G,EAAA6B,QACAxI,IACA2G,EAAA,MAEAA,IAAA3G,EAEAyG,EADAC,KAAAC,IAGAzB,GAAAuB,EACAA,EAAAzG,KAGAkF,GAAAuB,EACAA,EAAAzG,GAEAyG,IAAAzG,IACAyG,EAAAvB,IACAwB,EAAA2B,QACArI,IACA2G,EAAA6B,QACAxI,EAEAyG,EADAC,KAAAC,IAOAzB,GAAAuB,EACAA,EAAAzG,IAGAyG,IAAAzG,IAEAyG,EAAApC,EAAAoC,IAEAA,EAuEA,SAAA+B,KACA,IAAA/B,EAAAC,EAAAC,EAAAC,EAuCA,OApCAH,EAAAvB,GACAV,EAAAyC,KAAApH,EAAAqH,OAAAhC,MACAwB,EAAA7G,EAAAqH,OAAAhC,IACAA,OAEAwB,EAAA1G,EACA,IAAAwF,IAAkCc,GAAA7B,IAElCiC,IAAA1G,IACA2G,EAAA2B,QACAtI,IACA2G,EAAA,MAEAA,IAAA3G,IACA4G,EAAAyB,QACArI,EAEAyG,EADAC,KAAAC,EAAAC,IAOA1B,GAAAuB,EACAA,EAAAzG,KAGAkF,GAAAuB,EACAA,EAAAzG,GAEAyG,IAAAzG,IAEAyG,EAAApC,EAAAoC,IAEAA,EAKA,SAAA6B,KACA,IAAA9B,EAUA,OARA9B,EAAAuC,KAAApH,EAAAqH,OAAAhC,MACAsB,EAAA3G,EAAAqH,OAAAhC,IACAA,OAEAsB,EAAAxG,EACA,IAAAwF,IAAkCc,GAAA3B,IAGlC6B,EAGA,SAAA6B,KACA,IAAA5B,EAAAC,EAWA,GARAD,KACA7B,GAAAqC,KAAApH,EAAAqH,OAAAhC,MACAwB,EAAA7G,EAAAqH,OAAAhC,IACAA,OAEAwB,EAAA1G,EACA,IAAAwF,IAAkCc,GAAAzB,KAElC6B,IAAA1G,EACA,KAAA0G,IAAA1G,GACAyG,EAAAF,KAAAG,GACA9B,GAAAqC,KAAApH,EAAAqH,OAAAhC,MACAwB,EAAA7G,EAAAqH,OAAAhC,IACAA,OAEAwB,EAAA1G,EACA,IAAAwF,IAAsCc,GAAAzB,UAItC4B,EAAAzG,EAQA,OANAyG,IAAAzG,IAEAyG,EAAA3B,GAAA2B,IAEAA,EAKA,SAAAI,KACA,IAAAJ,EAgBA,OAbAzB,GAAAiC,KAAApH,EAAAqH,OAAAhC,MACAuB,EAAA5G,EAAAqH,OAAAhC,IACAA,OAEAuB,EAAAzG,EACA,IAAAwF,IAAkCc,GAAArB,KAElCwB,IAAAzG,IAEAyG,EAAAxC,KAEAwC,EAYA,IAAAlG,IAAgBkI,EAAA,SAAA5H,EAAA,SAAA6H,EAAA,oBAAAC,EAAA,kBAAAzH,EAAA,UAAA9B,EAAA,iBAAAwJ,EAAA,oBAAAC,EAAA,2BAAAtM,EAAA,iBAAAuM,EAAA,aAChB,QAAAlM,MAAA2D,MAAA3D,GAAAC,eAAA0D,GAAA3D,IACA,SAAAjB,GAAAiB,EAAA8E,GACAA,YACA,QAAArD,EAAAqD,EAAAlD,OAA6BH,KAAI,CACjC,IAAA/B,GAAiBM,OAAAJ,QAAA+D,GAAA3D,IAEjB,QAAAmM,KADAnM,KAAAoM,gBAAA1M,EAAAK,aACA+E,EAAArD,GAAA/B,EAAAyM,GAAArH,EAAArD,GAAA0K,GACArH,EAAArD,GAAA/B,EAEA,OAAAoF,EAMA,IAFA3B,EAAAK,OAEAJ,GAAAkF,KAAArF,EAAArB,OACA,OAAAuB,EAMA,MAJAA,IAAAC,GAAAkF,GAAArF,EAAArB,QACA8H,IA5vDY9G,KAAA,QAyEZ,SAAAtC,EAAAC,EAAAC,GACA,WAAAJ,EACAA,EAAAc,aAAAZ,EAAAC,GACAD,EACAC,EACAC,GAirDA6L,CACA1D,GACAD,GAAAzF,EAAArB,OAAAqB,EAAAqH,OAAA5B,IAAA,KACAA,GAAAzF,EAAArB,OACAuH,GAAAT,MAAA,GACAS,GAAAT","file":"2.index.js","sourcesContent":["// v1.0 exported just the parser function. To maintain backwards compatibility,\n// we export additional named features as properties of that function.\nvar parserFunction = require('./parser.js').parse;\nparserFunction.parseSVG = parserFunction;\nparserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;\nmodule.exports = parserFunction;\n\nfunction makeSVGPathCommandsAbsolute(commands) {\n\tvar subpathStart, prevCmd={x:0,y:0};\n\tvar attr = {x:'x0',y:'y0',x1:'x0',y1:'y0',x2:'x0',y2:'y0'};\n\tcommands.forEach(function(cmd) {\n\t\tif (cmd.command==='moveto') subpathStart=cmd;\n\t\tcmd.x0=prevCmd.x; cmd.y0=prevCmd.y;\n\t\tfor (var a in attr) if (a in cmd) cmd[a] += cmd.relative ? cmd[attr[a]] : 0;\n\t\tif (!('x' in cmd)) cmd.x = prevCmd.x; // V\n\t\tif (!('y' in cmd)) cmd.y = prevCmd.y; // X\n\t\tcmd.relative = false;\n\t\tcmd.code = cmd.code.toUpperCase();\n\t\tif (cmd.command=='closepath') {\n\t\t\tcmd.x = subpathStart.x;\n\t\t\tcmd.y = subpathStart.y;\n\t\t}\n\t\tprevCmd = cmd;\n\t});\n\treturn commands;\n}\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n      peg$startRuleFunction  = peg$parsesvg_path,\n\n      peg$c0 = function(data) {\n          if (!data) return [];\n          for (var cmds=[],i=0;i<data.length;i++) cmds=cmds.concat.apply(cmds,data[i]);\n          var first=cmds[0];\n          if (first && first.code=='m'){ // Per spec, first moveto is never relative\n            delete first.relative;\n            first.code = 'M';\n          }\n          return cmds;\n        },\n      peg$c1 = function(first, more) { return merge(first,more) },\n      peg$c2 = /^[Mm]/,\n      peg$c3 = peg$classExpectation([\"M\", \"m\"], false, false),\n      peg$c4 = function(c, first, more) {\n          var move = commands(c,[first]);\n          if (more) move = move.concat(commands(c=='M' ? 'L' : 'l',more[1]));\n          return move;\n        },\n      peg$c5 = /^[Zz]/,\n      peg$c6 = peg$classExpectation([\"Z\", \"z\"], false, false),\n      peg$c7 = function() { return commands('Z') },\n      peg$c8 = /^[Ll]/,\n      peg$c9 = peg$classExpectation([\"L\", \"l\"], false, false),\n      peg$c10 = function(c, args) { return commands(c,args) },\n      peg$c11 = /^[Hh]/,\n      peg$c12 = peg$classExpectation([\"H\", \"h\"], false, false),\n      peg$c13 = function(c, args) { return commands(c,args.map(function(x){ return {x:x}})) },\n      peg$c14 = /^[Vv]/,\n      peg$c15 = peg$classExpectation([\"V\", \"v\"], false, false),\n      peg$c16 = function(c, args) { return commands(c,args.map(function(y){ return {y:y}})) },\n      peg$c17 = /^[Cc]/,\n      peg$c18 = peg$classExpectation([\"C\", \"c\"], false, false),\n      peg$c19 = function(a, b, c) { return { x1:a.x, y1:a.y, x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c20 = /^[Ss]/,\n      peg$c21 = peg$classExpectation([\"S\", \"s\"], false, false),\n      peg$c22 = function(b, c) { return { x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c23 = /^[Qq]/,\n      peg$c24 = peg$classExpectation([\"Q\", \"q\"], false, false),\n      peg$c25 = function(a, b) { return { x1:a.x, y1:a.y, x:b.x, y:b.y } },\n      peg$c26 = /^[Tt]/,\n      peg$c27 = peg$classExpectation([\"T\", \"t\"], false, false),\n      peg$c28 = /^[Aa]/,\n      peg$c29 = peg$classExpectation([\"A\", \"a\"], false, false),\n      peg$c30 = function(rx, ry, xrot, large, sweep, xy) { return { rx:rx, ry:ry, xAxisRotation:xrot, largeArc:large, sweep:sweep, x:xy.x, y:xy.y } },\n      peg$c31 = function(x, y) { return { x:x, y:y } },\n      peg$c32 = function(n) { return n*1 },\n      peg$c33 = function(parts) { return parts.join('')*1 },\n      peg$c34 = /^[01]/,\n      peg$c35 = peg$classExpectation([\"0\", \"1\"], false, false),\n      peg$c36 = function(bit) { return bit=='1' },\n      peg$c37 = function() { return '' },\n      peg$c38 = \",\",\n      peg$c39 = peg$literalExpectation(\",\", false),\n      peg$c40 = function(parts) { return parts.join('') },\n      peg$c41 = \".\",\n      peg$c42 = peg$literalExpectation(\".\", false),\n      peg$c43 = /^[eE]/,\n      peg$c44 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c45 = /^[+\\-]/,\n      peg$c46 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c47 = /^[0-9]/,\n      peg$c48 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c49 = function(digits) { return digits.join('') },\n      peg$c50 = /^[ \\t\\n\\r]/,\n      peg$c51 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsesvg_path() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemoveTo_drawTo_commandGroups();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroups() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveTo_drawTo_commandGroup();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemoveTo_drawTo_commandGroup();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveto();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsedrawto_command();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsedrawto_command();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedrawto_command() {\n    var s0;\n\n    s0 = peg$parseclosepath();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselineto();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehorizontal_lineto();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevertical_lineto();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecurveto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsesmooth_curveto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsequadratic_bezier_curveto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseelliptical_arc();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveto() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    if (peg$c2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsecomma_wsp();\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parselineto_argument_sequence();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c4(s1, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclosepath() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parselineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselineto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselineto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehorizontal_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c11.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsenumber();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevertical_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c14.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c17.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecurveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecurveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecurveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecurveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecoordinate_pair();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c19(s1, s3, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c20.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesmooth_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesmooth_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesmooth_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c23.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequadratic_bezier_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsequadratic_bezier_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsequadratic_bezier_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c28.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseelliptical_arc_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelliptical_arc_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseelliptical_arc_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseelliptical_arc_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonnegative_number();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenonnegative_number();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsenumber();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomma_wsp();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseflag();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsecomma_wsp();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseflag();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsecomma_wsp();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsecoordinate_pair();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c30(s1, s3, s5, s7, s9, s11);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_pair() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c31(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonnegative_number() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefloating_point_constant();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsedigit_sequence();\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsefloating_point_constant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedigit_sequence();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c33(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseflag() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c34.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c36(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsecomma_wsp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c37();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c38;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c39); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloating_point_constant() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsefractional_constant();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseexponent();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexponent();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedigit_sequence();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c41;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c41;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsesign();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit_sequence() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c49(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c50.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c37();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n\n    function merge(first,more){\n      if (!more) return [first];\n      for (var a=[first],i=0,l=more.length;i<l;i++) a[i+1]=more[i][1];\n      return a;\n    }\n\n    var cmds = {m:'moveto',l:'lineto',h:'horizontal lineto',v:'vertical lineto',c:'curveto',s:'smooth curveto',q:'quadratic curveto',t:'smooth quadratic curveto',a:'elliptical arc',z:'closepath'};\n    for (var code in cmds) cmds[code.toUpperCase()]=cmds[code];\n    function commands(code,args){\n      if (!args) args=[{}];\n      for (var i=args.length;i--;){\n        var cmd={code:code,command:cmds[code]};\n        if (code==code.toLowerCase()) cmd.relative=true;\n        for (var k in args[i]) cmd[k]=args[i][k];\n        args[i] = cmd;\n      }\n      return args;\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n"],"sourceRoot":""}